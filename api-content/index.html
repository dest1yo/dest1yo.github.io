{"posts":[{"title":"COD19武器 名称-代码 对照一览表","content":" 突击步枪 代码名 备注 奇美拉 ar_mcbravo SIG MCX RATTLER CANEBRAKE 拉克曼 556 ar_kilo53 HK53 STB556 ar_augolf AUG M4 ar_mike4 M4 M16 ar_mike16 M16 卡斯托夫 762 ar_akilo AK103 卡斯托夫 74U ar_akilo74 AKS74U 卡斯托夫 545 ar_akilo105 AK105 M13B ar_mcharlie MCX 5.56口径 TAQ-56 ar_scharlie SCAR-L ISO 汉姆洛克 ar_acharlie300 APC223/300 Tempus Razorback ar_helima Hellion/VHS-2 ar_malima Malyuk 战斗步枪 代码名 备注 TAQ-V ar_schotel SCAR-H SO-14 dm_soscar14 Socom M14 弗基泰克侦察步枪 dm_msecho 458. SOCOM AR-15 拉克曼762 ar_golf3 HK G3A3 克洛南烈风 ar_ngsierra RM277 冲锋枪 代码名 备注 拉克曼微冲 sm_mpapa5 HK MP5A2 BAS-P sm_mpapax SIG MPX MX9 sm_apapa AUG 9 PARA 瓦兹涅夫9K sm_aviktor PP19-01勇士 FSS飓风 sm_alpha57 AR57 迷你巴克 sm_beta PP19野牛 菲内克45 sm_victor Vector.45 PDSW528 sm_papa90 P90 ISO 45 sm_acharlie45 ACP45 sm_uzulu UZI 霰弹枪 代码名 备注 洛克伍德300 sh_charlie725 Citori 725 布莱森800 sh_mbravo 590A1 布莱森890 sh_mviktor 590M 艾斯黛特12 sh_mike1014 M1014 KV 莫洛 sh_vecho Vepr-12 sh_tsierra TS-12 轻机枪 代码名 备注 RAAL lm_slima MG338 HCR56 lm_ahotel AUG-HBAR 伊卡洛斯556 lm_foxtrot Fightlite MCR RPK lm_rkilo RPK RAPP-H lm_kilo21 HK21 沙钦MG338 lm_ngolf7 内格夫NG7 lm_mkilo3 FN mini MK3(M249） 精确射手步枪 代码名 备注 LM-S dm_pgolf1 PSG-1 SPR-208 dm_mike24 M24 EBR-14 dm_mike14 MK14 EBR SA-B50 dm_sa700 洛克伍德MK2 dm_sbeta marlin TAQ-M dm_scromeo FN SCAR 20S 弩 dm_crossbow 泰普斯湍流 dm_stango25 SR25/MK11 狙击步枪 代码名 备注 MCPR-300 sn_mromeo Barret MRAD 维克图斯XMR sn_alpha50 AW50 西格诺50 sn_limax Lynx GM6 LA-B330 sn_la700 unknown SPX-80 sn_xmike2010 M2010 ESR FJX 帝国 sn_india 干预M200 sn_walpha WA2000 近战武器 代码名 备注 防爆盾牌 me_riotshield 战斗匕首 me_tac_knife01 双持小太刀 me_sword02 藤棍 me_kalistick 锤子 me_sledgehammer 斧子 me_hachet 警棍 me_xxxx 手枪 代码名 备注 X12 pi_golf17 Glock17 X13全自动 pi_golf18 Glock18 点50GS pi_decho Desert Eagle .50AE P890 pi_papa220 P220 巴西利斯克 pi_swhiskey S&amp;W M500 弗基泰克西奇 pi_tango9 Tec9 pi_mike2011 m2011 GS 马格纳 pi_decho/pi_dechoauto 全自动沙鹰 发射器 代码名 备注 RPG-7 la_rpapa7 RPG-7 针式导弹 la_gromeo 9K38 标枪导弹 la_juliet 标枪导弹 斯特莱拉P型 la_kgolf 古斯塔夫M4 瑞孚G-80 la_mike32 M32 ","link":"https://dest1yo.github.io/post/MW2022-codename/"},{"title":"UE5中烘培关键帧信息的插值函数实现方法","content":" UE5中烘培关键帧信息的插值函数实现方法 🍬使用环境 这是一段设置动画序列关键帧的代码： // 遍历骨骼信息映射 // InvalidBoneMaps为TMap&lt;int, FString&gt;类型，int为骨骼序号BoneIdx，FString为骨骼名BoneName for (TTuple&lt;int, FString&gt; BoneMap : InvalidBoneMaps) { int32 BoneIdx = BoneMap.Key; FName BoneName = FName(*BoneMap.Value); // 获取骨骼RefPose，仅作为动画信息示例 FTransform RefPoseTransform = RefSk.GetRefBonePose()[BoneIdx]; FVector RefPosePosition = RefPoseTransform.GetLocation(); FQuat RefPoseRotation = RefPoseTransform.GetRotation(); FVector RefPoseScale = RefPoseTransform.GetScale3D(); // 初始化一段总帧数长度的RefPose，包括Positon、Rotation、Scale TArray&lt;FVector&gt; PosData; PosData.Init(RefPosePosition, FrameCount); TArray&lt;FQuat&gt; RotData; RotData.Init(RefPoseRotation, FrameCount); TArray&lt;FVector&gt; ScaleData; ScaleData.Init(RefPoseScale, FrameCount); // 如果骨骼轨道添加成功 if (Controller.AddBoneCurve(BoneName)) { // 设置骨骼轨道所有关键帧 Controller.SetBoneTrackKeys(BoneName, PosData, RotData, ScaleData); } } 一般来说，想要在UE5里面给动画序列填充关键帧信息，要使用如下函数给骨骼轨道设置关键帧。 SetBoneTrackKeys(BoneName, PosData, RotData, ScaleData) 其中后三个Data参数均为总关键帧长度的动画数据数组，函数是根据数组元素位次给对应帧数设置关键帧信息。 如果我们输入的关键帧信息没有逐帧填有关键帧信息，就不能使用这个函数来直接设置动画序列的关键帧，这使得我们要给动画信息提前进行插值烘培成完整关键帧数组。 💡 如果我们有一个总帧数14的动画，关键帧信息并不是逐帧的，比如仅有帧{1, 5, 7, 10}，如果我们想烘培成{0, 1, 2, 3, 4, 5, 6, 7, 8 ,9, 10, 11, 12, 13}，则需要编写一个插值函数用以烘培完整关键帧信息。 🍪函数实现 Lerp Functions 定义重载函数以实现多种类型的插值 // FTransform Lerp static FTransform LerpSomething(const FTransform&amp; A, const FTransform&amp; B, const float&amp; Alpha) { return FTransform { FQuat::Slerp(A.GetRotation(), B.GetRotation(), Alpha) , FMath::Lerp(A.GetLocation(), B.GetLocation(), Alpha) , FMath::Lerp(A.GetScale3D(), B.GetScale3D(), Alpha) }; } // FVector Lerp static FVector LerpSomething(const FVector&amp; A, const FVector&amp; B, const float&amp; Alpha) { return FMath::Lerp(A, B, Alpha); } // FQuat SLerp static FQuat LerpSomething(const FQuat&amp; A, const FQuat&amp; B, const float&amp; Alpha) { return FQuat::Slerp(A, B, Alpha); } Interpolate Function 使用模版类以实现多种类型的插值 // Interpolate function for types: FVector / FQuat / FTransform // TMap&lt;int32, T&gt; =&gt; &lt;Frame, AnimInfo&gt; template&lt;typename T&gt; // UFUNCTION(BlueprintCallable, Category = &quot;AnimHelper&quot;) static TMap&lt;int32, T&gt; InterpolateSomething(const TMap&lt;int32, T&gt;&amp; InTransformMap, int32 FrameCount) { // Step 1 // 定义OutTransformMap并提前预留好内存大小，即总关键帧长度 TMap&lt;int32, T&gt; OutTransformMap; OutTransformMap.Reserve(FrameCount); // 获取第一帧和最后一帧 constexpr int32 StartFrame = 0; const int32 EndFrame = FrameCount - 1; // 找到第一个关键帧 int32 StartKeyframe = InTransformMap.begin()-&gt;Key; // 找到最后一个关键帧，因为TMap.end()获取的是最后一个元素的下一个元素，所以要转成数组再提出最后一帧的位置 int32 EndKeyframe = InTransformMap.Array().Last().Key; // Step 2 // 如果第一个关键帧并不为第一帧(0)，则填充第一帧到第一个关键帧的前一帧为第一个关键帧 // [StartFrame, StartKeyframe) = StartKeyframe.Value if (StartFrame &lt; StartKeyframe) { for (int Frame = StartFrame; Frame &lt; StartKeyframe; ++Frame) { OutTransformMap.Emplace(Frame, InTransformMap[StartKeyframe]); } } // Step 3 // 遍历从第一个关键帧到最后一个关键帧 for (int32 CurrentFrame = StartKeyframe; CurrentFrame &lt;= EndKeyframe; ++CurrentFrame) { T BakedFrameData; // 如果当前帧有关键帧, 直接复制 if (InTransformMap.Contains(CurrentFrame)) { BakedFrameData = InTransformMap[CurrentFrame]; OutTransformMap.Emplace(CurrentFrame, BakedFrameData); } else //如果当前帧没有关键帧，则进行插值 { // 找到前一个帧和后一个帧 int32 PreviousKeyframe = CurrentFrame - 1; int32 NextKeyframe = CurrentFrame + 1; // 找到前后最近的关键帧 // 查找前一个关键帧 while (!InTransformMap.Contains(PreviousKeyframe)) { --PreviousKeyframe; if (PreviousKeyframe &lt; StartKeyframe) { // 如果前一个关键帧不存在，将其设置为第一个关键帧 PreviousKeyframe = StartKeyframe; break; } } // 查找后一个关键帧 while (!InTransformMap.Contains(NextKeyframe)) { ++NextKeyframe; if (NextKeyframe &gt; EndKeyframe) { // 如果后一个关键帧不存在，将其设置为最后一个关键帧 NextKeyframe = EndKeyframe; break; } } const float SampleStep = NextKeyframe - PreviousKeyframe; for (int f = PreviousKeyframe + 1; f &lt; NextKeyframe; ++f) { // 计算插值 float Alpha = float(f - PreviousKeyframe) / SampleStep; BakedFrameData = LerpSomething(InTransformMap[PreviousKeyframe], InTransformMap[NextKeyframe], Alpha); OutTransformMap.Emplace(f, BakedFrameData); } CurrentFrame = NextKeyframe - 1; } } // Step 4 // 如果最后一个关键帧小于最后一帧，补充空缺的帧数全为最后一个关键帧 if (EndKeyframe &lt; EndFrame) { for (int Frame = EndKeyframe + 1; Frame &lt;= EndFrame; ++Frame) { OutTransformMap.Emplace(Frame, InTransformMap[EndKeyframe]); } } // Step 5 // OutTransformMap.GenerateValueArray(); // 可以使用GenerateValueArray()输出变换信息数组 return OutTransformMap; } 🍨测试例 // UFUNCTION(BlueprintCallable, Category = &quot;AnimHelper&quot;) static void Debuger_Print() { TMap&lt;int32, FTransform&gt; OriginalTransformMap = { { 1, FTransform(FQuat(1,2,3,4), FVector(1,1,1), FVector(1,1,1)) } , { 3, FTransform(FQuat(1,2,3,4), FVector(3,3,3), FVector(1,1,1)) } , { 5, FTransform(FQuat(1,2,3,4), FVector(5,5,5), FVector(1,1,1)) } , { 8, FTransform(FQuat(1,2,3,4), FVector(8,8,8), FVector(1,1,1)) } , { 15, FTransform(FQuat(1,2,3,4), FVector(15,15,15), FVector(1,1,1)) } , { 20, FTransform(FQuat(1,2,3,4), FVector(20,20,20), FVector(1,1,1)) } , { 30, FTransform(FQuat(1,2,3,4), FVector(30,30,30), FVector(1,1,1)) } }; TMap&lt;int32, FTransform&gt; OutTransformMapT = InterpolateSomething(OriginalTransformMap, 35); for (auto TransformMap : OutTransformMapT) { SEAnim_Debug::DebugString(FString::FromInt(TransformMap.Key), TransformMap.Key), TransformMap.Value.ToString()); } TMap&lt;int32, FVector&gt; OriginalPositionMap = { { 1, FVector(1,1,1) } , { 3, FVector(3,3,3) } , { 5, FVector(5,5,5) } , { 8, FVector(8,8,8) } , { 15, FVector(15,15,15) } , { 20, FVector(20,20,20) } , { 30, FVector(30,30,30) } }; TMap&lt;int32, FVector&gt; OutTransformMap = InterpolateSomething(OriginalPositionMap, 35); for (auto TransformMap : OutTransformMap) { SEAnimDebuger::DebugString(FString::FromInt(TransformMap.Key), TransformMap.Key), TransformMap.Value.ToString()); } } ","link":"https://dest1yo.github.io/post/interpolate-keyframes-function-in-unreal-5/"}]}